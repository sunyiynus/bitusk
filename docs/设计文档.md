# bituskä¸€äº›ä»£ç ç»†èŠ‚è€ƒé‡

æŠ½è±¡å·¥å‚å¦‚ä½•åˆå§‹åŒ–message generator

```cpp
class AbsMessageGenerator;
class GeneratorFactory{
public:
	AbsMessageGenerator* GetGenerator(Peer& peer, std::vector<int> value_list);
};

AbsMessageGenerator* GeneratorFactory::GetGenerator(Peer& peer,int msg_type ,
																											std::vector<int> value_list = std::vector<int>())
{
	switch(msg_type){
		case 1:
			if( value_list.size() > 2) // check the value
			{
				return Generator1(value_list);
			}
			return nullptr;
			break;
		case 2:
			// the same with above
			break;
	}
};

class Generator1: public AbsMessageGenerator {
public:
	Generator1(const std::vector<int>& value_list) {
		self->elemet = value_list;
		if( value_list.size() < 2){
			self->elemet.push_back(1); // å¯ä»¥å¼ºè¡ŒæŒ‡å®šåˆå§‹åŒ–
		}
	}
};
```

ä¿è¯ç±»å‹å®‰å…¨çš„ä¸¤ç§æ–¹æ³•ä¹‹ä¸€å°±æ˜¯åˆ©ç”¨å·¥å‚æˆ–æŠ½è±¡å·¥å‚æ£€æŸ¥ä¼ å…¥å€¼æ˜¯å¤Ÿæ˜¯ç±»å‹å¯å–å€¼ã€‚

<aside>
ğŸ’¡ å¦å¤–ä¸€ç§æ–¹æ³•æ˜¯ï¼šåˆ©ç”¨æ„é€ å‡½æ•°æ¥æ£€æŸ¥ã€‚

</aside>

bcode parserä¸ä½¿ç”¨switchå®ç°

Bç¼–ç ä¸­æœ‰å››ç§ç±»å‹ï¼šstringï¼Œintegerï¼Œdictionaryï¼Œlistã€‚ç¤ºä¾‹åˆ†åˆ«å¦‚ä¸‹ï¼š

integer: i43e è¡¨ç¤ºæ•°å­—32ã€‚

string:  5:world å‰é¢æ•°å­—è¡¨ç¤ºå­—ç¬¦é•¿åº¦ä¸º5ï¼Œå­—ç¬¦ä¸²ä¸ºworldã€‚

dictionary: d9:publisher3:bobeè¡¨ç¤ºkeyï¼špublisherï¼Œvalueï¼šbobã€‚

listï¼šl4ï¼šworlde è¡¨ç¤ºåˆ—è¡¨æˆå‘˜worldã€‚

![graphviz (9).svg](bitusk%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82%E8%80%83%E9%87%8F%20fe5ae44666e74f1c97c8c14a40f34f8c/graphviz_(9).svg)

å®ç°1ï¼š

è¿™ç§ä¸»è¦ä¹Ÿæ˜¯åˆ©ç”¨å‡½æ•°æŒ‡é’ˆæ¥ä¿å­˜ä¸€ä¸ªprocessorï¼Œæ¯ä¸ªprocessorå¯¹åº”ä¸€ä¸ªçŠ¶æ€ã€‚å¤„ç†å®Œå¯¹åº”çš„åŒºå—ä¿¡æ¯å°±è¿”å›ä¸‹ä¸€ç§å¤„ç†æ–¹æ³•ã€‚å¯¹äºåµŒå¥—ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨é€’å½’æ¥åšã€‚

```cpp

class BecodeParser{
public:
    void start(const std::string& str)
    {
        std::string::const_iterator itr = str.cbegin();
        shiftState(itr);
        while( itr != str.cend() ) {
            processor(itr);
        }
    }
    void processDictionary(std::string::const_iterator& itr) {
        // process
        shiftState(++itr);
    }

    void processList(std::string::const_iterator& itr) {
        // process
        shiftState(++itr);
    }

    void processInterger(std::string::const_iterator& itr) {
        // process
        shiftState(++itr);
    }

    void processString(std::string::const_iterator& itr) {
        // process
        shiftState(++itr);
    }

    void shiftState(std::string::const_iterator& itr){
        if( *itr == 'l') processor = processList;
        if( *itr == 'i') processor = processInterger;
        if( isNumber(itr) ) processor = processString;
    }

    void(*processor)(std::string::const_iterator& itr);
};
```

å®ç°2ï¼š

åˆ©ç”¨å’Œç±»å‹æ¥å®ç°ï¼Œåœ¨TypeScriptä¸­æœ‰å’Œç±»å‹ï¼Œä½†æ˜¯c++ä¸­åˆ™æ²¡æœ‰ã€‚ä½†æ˜¯cppå¯ä»¥ç”¨åŸºç±»æŒ‡é’ˆæ¥æ¨¡æ‹Ÿå’Œç±»å‹ã€‚å…·ä½“å®ç°è§ä»£ç ã€‚

```cpp
class AbsBecodeType{
public:
    virtual AbsBecodeType* Parser(std::string::const_iterator& itr);
};

class ListParser: public AbsBecodeType{
public:
    virtual AbsBecodeType* Parser(std::string::const_iterator& itr);
};

class DictionaryParser: public AbsBecodeType{
public:
    virtual AbsBecodeType* Parser(std::string::const_iterator& itr);
};

class IntergerParser: public AbsBecodeType{
public:
    virtual AbsBecodeType* Parser(std::string::const_iterator& itr) {
        // processe
        if( *itr == l) return std::make_shared<ListParser>();
    }
};

void processBcodeStr(const std::string& str) {
    std::shared_ptr<AbsBecodeType> processor = std::make_shared<IntergerParser>();
    std::string::const_iterator itr = str.cbegin();
    while( itr != str.cend() ) {
        processor.reset(processor->Parser(itr));
    }
}
```

ç°åœ¨peeræ¨¡å—ä¸messageæ¨¡å—è€¦åˆåº¦å¤ªé«˜ï¼Œmessageæ¨¡å—ä¼šç›´æ¥ä¿®æ”¹peerçš„æ•°æ®çŠ¶æ€ã€‚è¿™å°±æ˜¯å®ç°ä¾èµ–äºå…·ä½“é€ æˆçš„åæœã€‚æˆ‘éœ€è¦ç”¨å¦å¤–ä¸€ç§å®ç°å†™ä¸»é€»è¾‘FSMï¼Œå»æ‰peer.stateè¿™ä¸ªå˜é‡ï¼Œé‡‡ç”¨processoræŒ‡é’ˆä»£æ›¿stateï¼Œé‚£ä¹ˆæˆ‘ä¹Ÿè¦æ”¹åŠ¨messageæ¨¡å—çš„å…·ä½“å®ç°ï¼Œè¿™å¾ˆéš¾å—ã€‚å¯ä»¥è€ƒè™‘Visitoræ¨¡å¼ï¼Œåªæ˜¯æŠŠstruct peeræ•°æ®ç»“æ„å½“åšæ•°æ®å‚¨å­˜çš„åœ°æ–¹ï¼Œä¿®æ”¹å’Œè¯»å–éƒ½æ”¾åœ¨å…¶ä»–classã€‚è¿™ç§æ–¹æ³•å¥½åƒä¹Ÿå¹¶æ²¡æœ‰è§£å†³ç°åœ¨çš„é—®é¢˜ï¼Œä¹Ÿè¿˜æ˜¯éœ€è¦ä¿®æ”¹messageæ¨¡å—ã€‚è¿˜æœ‰ä¸€ç§å°±æ˜¯å®šä¹‰ä¸€ä¸ªpeerçš„ç»Ÿä¸€çš„interfaceï¼Œè¿™ä¸ªinterfaceæŠ½è±¡å°±è¡Œã€‚messageæ¨¡å—ä¾èµ–äºæŠ½è±¡çš„interfaceæ¥å®ç°ã€‚

peeræ•°æ®äº¤æ¢æ¨¡å—çš„è®¾è®¡

![Untitled](bitusk%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82%E8%80%83%E9%87%8F%20fe5ae44666e74f1c97c8c14a40f34f8c/Untitled.png)

PeersManageråªéœ€è¦ä¸åœåœ°async_writeå’Œasync_readï¼Œä»¥åŠå¤„ç†disconnectï¼Œç§»é™¤é˜Ÿåˆ—çš„æ“ä½œå°±å¯ä»¥äº†ã€‚ç»†èŠ‚å¤„ç†è¿˜æ˜¯äº¤ç»™peerå«æœ‰çš„ä¸åŒçš„functional objectsã€‚è¿™æ ·æ—¢å®ç°äº†çŠ¶æ€æœºçš„æ“ä½œï¼Œå‡å°‘äº†ç»„ä»¶ä¹‹é—´çš„è€¦åˆåº¦ã€‚

messageæ¨¡å—å¦‚ä½•èŠ‚çœä»£ç ï¼Ÿ

æˆ‘è§‚å¯Ÿï¼Œæœ‰äº›messageæ¨¡å—çš„å¤„ç†çš„ä¸œè¥¿æ­¥å‡‘åŸºæœ¬ä¸€è‡´ï¼Œæ¯”å¦‚ï¼š

```cpp
	
void ProcessHaveMsg::ParseMessage(Peer& peer, const ustring& msg)
{
    int len = CharToInt(msg.c_str());
    ustring context (msg.cbegin()+5, msg.cbegin() + 5 + len);
    // convert have msg to what i need;
    // è¿™å„¿åº”è¯¥å’Œé‚£ä¸ªpieceæœ‰å…³éœ€è¦æ›´æ”¹bitmap
}
```

decoratoræ¨¡å¼å¯ä»¥æå®šã€‚å½“ç„¶åŸºç±»ä¸­ä¹Ÿå¯ä»¥ç‰¹å®šå®ç°è¿™ä¸ªå‡½æ•°ï¼Œç„¶åè®©åé¢çš„ç»§æ‰¿ä½¿ç”¨ï¼Œä½†æ˜¯æœ‰äº›å­ç±»å¹¶ä¸éœ€è¦è¿™ä¸ªå‡½æ•°ã€‚è¿™ç§è®¾è®¡æœ‰äº›å¤šä½™ã€‚decoratoræ¨¡å¼å®ç°å¯ä»¥è¿™æ ·å†™ï¼š

```cpp
void CopyMsg::ParseMessage(Peer& peer, const ustring& msg)
{
    int len = CharToInt(msg.c_str());
    ustring context (msg.cbegin()+5, msg.cbegin() + 5 + len);
		ustring& mmsg = const_cast<ustring&>(msg);
		mmsg.clear(); mmsg = context;
}

void ProcessBitfieldMsg::ParseMessage(Peer& peer, const ustring& msg)
{
		CopyMsg copymsg;
		copymsg.ParseMessage(msg);
    std::vector<bool> tmp_bits;
    const unsigned char* bits = msg.c_str();
    assert(len * 8 >= peer.bitmap.Size());
    for( int i = 0; i < peer.bitmap.Size(); ++i )
    {
        bool bit = bits[i / 8] & (1<< (i%8));
        tmp_bits.push_back(bit);
    }
}
```

data cacheçš„è®¾è®¡çœŸè®©äººå¤´ç–¼ï¼Œè¦ä¸è¦å…ˆå†™æµ‹è¯•å§

file io çœŸæ˜¯ä¸€ä¸ªè®©äººå¤´å¤§çš„é—®é¢˜ã€‚æœ‰ä¸¤ç§ç­–ç•¥æ¥å®ç°æ–‡ä»¶å†™å…¥ï¼›å…¶ä¸€ï¼Œå…ˆå†™ä¸€ä¸ªæ•´æ–‡ä»¶.tmpï¼Œæ–‡ä»¶ä¸‹è½½ç»“æŸåï¼Œå†æ ¹æ®å„ä¸ªæ–‡ä»¶çš„ä¿¡æ¯æ¥åˆ›å»ºå„ä¸ªæ–‡ä»¶ï¼›å…¶äºŒï¼Œæ ¹æ®pieceä½ç½®æŒ‡å®šå†™å“ªä¸ªæ–‡ä»¶ï¼Œåœ¨å¤šæ–‡ä»¶æ¨¡å¼ä¸‹ã€‚å½“ç„¶ç¬¬ç¬¬ä¸€ç§å®ç°èµ·æ¥æ¯”ç¬¬äºŒç§å®ç°èµ·æ¥è½»æ¾å¤šäº†ã€‚ä½†æ˜¯æˆ‘è¿˜æ˜¯æƒ³æŒ‘æˆ˜ä¸€ä¸‹ç¬¬äºŒç§å®ç°ã€‚ä¸ºäº†æ”¯æŒä¸¤ç§ç­–ç•¥ï¼Œæˆ‘å°±å®šä¹‰ä¸€ä¸ªæŠ½è±¡åŸºç±»AbsFilesManageræ¥æä¾›æœ€åŸºæœ¬çš„nodeçš„è¯»å†™ï¼Œä»¥åŠç®¡ç†å†™æ–‡ä»¶ã€‚å°±æ˜¯åŸåˆ™ä¸­çš„ï¼Œé’ˆå¯¹æ¥å£ç¼–ç¨‹ï¼Œè€Œä¸æ˜¯å®ç°ã€‚

ä¸ºäº†æä¾›æ›´å¼ºå¤§å’Œå¤šæ ·çš„è¯»å†™é‡ï¼Œæ¯”å¦‚æˆ‘è¿˜æƒ³è¯»æ•´ä¸ªpieceï¼Œé‚£ä¹ˆæˆ‘å¯ä»¥åœ¨åŸºç±»ä¸­å¢åŠ æ¥å£ï¼Œä½†æ˜¯ä¿æŒæ¥å£å°‘è€Œç²¾ï¼Œå¯ä»¥æå¤§ç¼“è§£æˆ‘ç»´æŠ¤è¿™ä¸ªç±»çš„éš¾åº¦ã€‚é‚£ä¹ˆè‡ªç„¶è€Œç„¶å°±æ˜¯decoratoræ¨¡å¼æ¥æä¾›æ¥å£çš„å¢å¼ºã€‚è®¾è®¡ä¸€ä¸ªFilesManagerDecoratoræ¥å¢å¼ºæˆ‘çš„è¯»å†™ã€‚è€Œä¸”è¿˜èƒ½æ”¯æŒä¸¤ç§ç­–ç•¥ã€‚

```cpp
class AbsFileManager{
public:
    AbsFileManager(const std::string& dd): download_dir_(dd) {}
    AbsFileManager(const std::string& dd, const std::vector<File>& files): download_dir_(dd), files_info_(files) {}
    // read from disk
    virtual bool LoadingFiles() = 0;
    virtual void ReadSliceNodeFromDisk(Node& node) = 0;
    virtual const Node ReadSliceNodeFromDisk(size_t index, size_t offset, size_t length)  = 0;
    virtual bool WriteSliceNodeToDisk(const Node& node)  = 0;
    virtual bool IntegrateFiles()  = 0;
protected:
    std::string download_dir_;
    std::vector<File> files_info_;
};

class FilesManagerSV:public AbsFileManager{
private:
    std::shared_ptr<std::iostream> fs_;
    size_t piece_length_;
    size_t total_length_;

public:
    // must firstly loading files
    virtual bool LoadingFiles() override;
    virtual void ReadSliceNodeFromDisk(Node& node) override;
    virtual const Node ReadSliceNodeFromDisk(size_t index, size_t offset, size_t length) override;
    virtual bool WriteSliceNodeToDisk(const Node& node) override;
    virtual bool IntegrateFiles() override;
public:
    const bool IsFileReady() const;
};

class FilesManagerDecorator: public AbsFileManager {
public:
// decorator æ¨¡å¼çš„åˆ©ç”¨
private:
		std::shared_ptr<AbsFilesManager> fmanager_;
}
```

æˆ‘ç°åœ¨æœ‰ç§éœ€æ±‚ï¼Œå°±æ˜¯å¯ä»¥åœ¨å…¨å±€ä»»æ„ä½ç½®ï¼Œè·å–ä¸€ä¸ªå¯¹è±¡ï¼Œæ¯”å¦‚peersçš„æ•°æ®ç»“æ„ï¼Œå¾ˆå¤šåœ°æ–¹éƒ½ä¼šç”¨åˆ°ã€‚singletonåº”è¯¥å¯ä»¥æ»¡è¶³éœ€æ±‚ã€‚ç«Ÿç„¶singletonä¹Ÿæœ‰å¤šçº¿ç¨‹çš„é—®é¢˜ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚

ç¬¬ä¸€æ¬¡åˆå§‹åŒ–staticå˜é‡ï¼Œéœ€è¦ä¸€äº›ç¯å¢ƒå€¼æ¥åšåˆå§‹åŒ–ã€‚ç„¶ååé¢å°±å¯ä»¥ç›´æ¥ä½¿ç”¨äº†ã€‚ä½†æ˜¯æˆ‘æƒ³è¦æˆ‘çš„æ¥å£ç®€æ´ä¸€ç‚¹ã€‚

```cpp
struct X {
		static getInstance(int x) {
				static X px(x);
		}

		int m;
};

void test_1() {
		X& tmpx = X::getInstance(40);
}

void test_2 {
		X& tmpc = X::getInstance();
}
```

ç°åœ¨æœ‰ä¸¤ç§æ–¹æ¡ˆï¼Œå°†static X xæ”¾åœ¨å‡½æ•°é‡Œé¢ï¼Œè¿™æ ·æˆ‘åªèƒ½é‡‡ç”¨ä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–ä¸€äº›å˜é‡ï¼Œä½†æ˜¯æˆ‘è¦åœ¨è¿è¡Œæ—¶å†³å®šè¦åˆå§‹åŒ–çš„ä¸œè¥¿ï¼Œæš‚æ—¶è¿˜æ²¡æƒ³åˆ°æœ‰ä»€ä¹ˆå¥½çš„æ–¹æ¡ˆã€‚è¿‚å›ä¸€ç‚¹ï¼Œæˆ‘å°±å®ç°å¦å¤–ä¸€ä¸ªæˆå‘˜å‡½æ•°ï¼ŒX::initæ¥æ‰‹åŠ¨åˆå§‹åŒ–ã€‚è¿™æ ·ä¹Ÿè¡Œï¼Œä½†æ˜¯ä¸å¤Ÿä¼˜é›…ã€‚

ç¬¬äºŒç§æ–¹æ¡ˆï¼Œåœ¨ç±»é‡Œé¢æ”¾ä¸€ä¸ª static std::shared_ptr<X> ç„¶åæˆ‘å°±å¯ä»¥ å¯ä»¥å®šä¹‰ä¸¤ä¸ªå…¬å…±æ¥å£ï¼Œä¸€ä¸ªåˆå§‹åŒ–ï¼Œä¸€ä¸ªå…¨å±€è¿”å›ï¼Œè¿™æ ·æ¥å£è®¾è®¡ä¸Šç¬¦åˆç›´è§‰ã€‚ä½¿ç”¨ç®€å•ã€‚ä½†æ˜¯è¿™æ ·æœ‰ä¸ªæ½œåœ¨çš„å½±å“ï¼Œå°±æ˜¯thread safeçš„é—®é¢˜å€’æ˜¯çœ‹åˆ°ä¸€äº›thread safe singletonçš„è®¾è®¡æœ‰ç‚¹ä¸å¤ªæ‡‚ã€‚

```cpp
// !!!! Can't working
class Singleto_new {
    private:
        Singleto_new();
        Singleto_new(const Singleto_new& );
    public:
        Singleto_new* getInstance(); 
        std::atomic<Singleto_new*> m_instance; // è¿™å„¿ä¸å®šä¹‰staticå¦‚ä½•ç¡®ä¿singletonï¼Ÿï¼Ÿ
        std::mutex m_mutex;
};
    
//çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬çš„å•ä¾‹æ¨¡å¼
Singleto_new* Singleto_new::getInstance() {
    
    Singleto_new* tmp = m_instance.load(std::memory_order_relaxed);   //è·å–å†…å­˜fence
    std::atomic_thread_fence(std::memory_order_acquire);
    if(nullptr == tmp) {
        std::lock_guard<std::mutex>  lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if(nullptr == tmp) {
            tmp = new Singleto_new;
            std::atomic_thread_fence(std::memory_order_release);   //é‡Šæ”¾å†…å­˜
            m_instance.store(tmp, std::memory_order_relaxed);
        }
    }
    return tmp;
}
```

```cpp

//ç½‘ä¸Šæ‰¾çš„ä¸€ä¸ªæ ·æ¿æœ‰é”™è¯¯ï¼Œè¿™æ˜¯ä¿®æ­£è¿‡çš„ç‰ˆæœ¬
class Singleto_new {
    private:
        Singleto_new();
        Singleto_new(const Singleto_new& );
    public:
        static Singleto_new* getInstance(); 
	      inline static std::atomic<Singleto_new*> m_instance;  // c++ 17 support inline static
																															// for older version just needed to define
        inline static std::mutex m_mutex;
};

Singleto_new::m_instance;
Singleto_new::m_mutex;

//çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬çš„å•ä¾‹æ¨¡å¼
Singleto_new* Singleto_new::getInstance() {
    // double check, single lock
    Singleto_new* tmp = m_instance.load(std::memory_order_relaxed);   //è·å–å†…å­˜fence
    std::atomic_thread_fence(std::memory_order_acquire);
    if(nullptr == tmp) {
        std::lock_guard<std::mutex>  lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if(nullptr == tmp) {
            tmp = new Singleto_new;
            std::atomic_thread_fence(std::memory_order_release);   //é‡Šæ”¾å†…å­˜
            m_instance.store(tmp, std::memory_order_relaxed);
        }
    }
    return tmp;
}

// support different c++ version
#if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L ) || __cplusplus >= 201703L )
    inline static std::atomic<FilesManagerSV*> mfm_instance;
    inline static std::mutex m_mutex;
#else
    static std::atomic<FilesManagerSV*> mfm_instance;
    static std::mutex m_mutex;
#endif
```

è®¾è®¡æˆå…¨å±€ä¸€ä¸ªstaticé‚£ä¸æ˜¯å°±ä¸èƒ½æ”¯æŒå¤šä¸ªä¸‹è½½åŒæ—¶è¿›è¡Œäº†ï¼Ÿï¼Ÿ

ä½†æ˜¯å¯ä»¥å¤šè¿›ç¨‹ä¸‹è½½å•Šï¼å¦‚æœè¿›ç¨‹å¦‚ä½•åˆ¤æ–­æ˜¯å¦ä¹Ÿæœ‰è¿›ç¨‹åœ¨è¯»è¿™ä¸ªæ–‡ä»¶ã€‚åŠ ä¸ª.lockæ–‡ä»¶ã€‚GUIç¨‹åºè°ƒç”¨è¿™ä¸ªè¿›ç¨‹ä¸‹è½½ï¼Œæ”¯æŒRPCè·å–ä¸‹è½½æƒ…å†µã€‚

å…¶å®å¯ä»¥å…¨å±€ç»´æŠ¤ä¸€ä¸ªMultiFileManagerï¼Œè®©è¿™ä¸ªåšæˆsingletonï¼Œç„¶åå¯ä»¥æ ¹æ®hash_infoè®¿é—®å¯¹åº”æ–‡ä»¶çš„ã€‚

æˆ–è€…æ”¾åœ¨çº¿ç¨‹å†…éƒ¨ç»´æŠ¤ï¼Ÿï¼Ÿ

Request msgçš„ç»´æŠ¤ä¸Šç¡®å®æœ‰ç‚¹æ£˜æ‰‹ï¼Œmatefileå¯¹è±¡æ¥å£è®¾è®¡çš„å¹¶æ²¡æœ‰æ»¡è¶³çµæ´»çš„éœ€æ±‚ã€‚ç°åœ¨å°±éœ€è¦å„ç§ç‰¹æ®Šå‡½æ•°æ¥æå®šä¸€äº›æ–‡ä»¶ä¸Šçš„å¤„ç†ã€‚

ä¸»è¦æ»¡è¶³ä¸ä¸€æ ·çš„tracker protocolï¼ˆhttpï¼ŒUDPï¼‰ç›®å‰æ”¯æŒè¿™ä¸¤ç§trackerï¼Œä¸ºäº†ç®€åŒ–ä»£ç ç»“æ„ï¼Œè®©ç»“æ„çœ‹ä¸Šå»æ›´åŠ æ¸…æ™°æ˜“è¯»ã€‚

TrackersManagerå¯ä»¥å‘io_contextæ³¨å†Œäº‹ä»¶ï¼Œæ¥å®šæœŸæ¸…ç†æˆ–è€…é‡æ–°è¿æ¥trackerï¼Œè¿æ¥çš„ç»†èŠ‚éƒ½äº¤ç»™AbsTrackerProtocolçš„å­ç±»ã€‚

```cpp
class AbsTrackerProtocol {
public:
    virtual bool Connecting(const std::string& url);
    virtual bool IsActive() const ;
};

class UDPTracker: public AbsTrackerProtocol{
public:
    virtual bool Connecting(const std::string& url);
    virtual bool IsActive() const ;

protected:
    ip::udp::endpoint ep_;
    io_context& ioc_;
    int is_connnectable_;
};

class HttpTracker: public AbsTrackerProtocol{

};

class TrackersManager{
public:  
    void ConnectingTrackers();
    void ClearUnconnectableTracker();
private:
    std::list<boost::shared_ptr<AbsTrackerProtocol>> trackers_;
};
```